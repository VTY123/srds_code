#include "./demo_sim_mst_ibe.h"

void demo_mst_ibe(public_parameters pp, int num_client, int verification_flag, char *dir)
{
	char pth[128];
	strcpy(pth, dir);

	//char buf[128];
	// initialize clients' variables for secret keys and contributions of public parameters.
	element_t *clients_sk = malloc(sizeof(element_t) * (num_client + 1));
	element_t *clients_g1 = malloc(sizeof(element_t) * (num_client + 1));

	// initialize clients' variables for zero knowledge proof or pkVerify
	element_t *Tptr = malloc(num_client * sizeof(element_t));
	element_t *cptr = malloc(num_client * sizeof(element_t));
	element_t *wptr = malloc(num_client * sizeof(element_t));

	// benchmark the total time of keysetup algorithm

	for (int i = 0; i < num_client; i++)
	{
		waters_keysetup(pp, clients_sk[i], clients_g1[i]);
		zk_proof(clients_sk[i], pp->g, clients_g1[i], Tptr[i], cptr[i], wptr[i], pp->pairing);
		element_printf("the %d-th user generates its secret key, public parameter, and zero-knowledge proof\n",i);
	}


	/*Reppository server computation BEGIN*/
	// benchmark pkVerify
	for (int i = 0; i < num_client; i++)
	{
		element_printf("the server verifies the %d-th user's public parameter\n",i);
		int t = waters_pkVerify(wptr[i], Tptr[i], cptr[i], pp->g, clients_g1[i], pp->pairing);
		if (t != 0)
		{
			printf("pkVerify fails\n");
		}
	}

	/*Reppository server computation END*/

	// Note: the verification time is the sum of the server computation and clients' computation
	dk **clients_dks = malloc(sizeof(dk *) * num_client);
	for (int i = 0; i < num_client; i++)
	{
		clients_dks[i] = malloc(sizeof(dk) * num_client);
	}
	// benchmark keyder
	for (int i = 0; i < num_client; i++)
	{
		for (int id = 1; id <= num_client; id++)
		{
			waters_keyder(clients_dks[i][id - 1], pp, clients_sk[i], id);
			element_printf("the %d-th user derives a decryption key for the user with id = %d\n",i,id-1,id);
		}
	}


	// benchmark dkVerify
	for (int i = 0; i < num_client; i++)
	{
		for (int id = 1; id <= num_client; id++)
		{
			element_printf(" verifying the decryption key generated by the %d-th user for the user with id = %d\n",i,id);
			int r = waters_dkVerify(pp, clients_g1[i], id, clients_dks[i][id - 1]);
			if (r != 0)
			{
				printf("dkVerify fails\n");
			}
		}
	}


	// the trusted repository server computation BEGIN
	// benchmark pCombine

	element_printf("simulating the computation by the server \n");

	element_t g1;
	element_init_G1(g1, pp->pairing);

	element_set(g1, clients_g1[0]);
	element_printf("the server combines the contribution to public paramter by the %d-th user\n",0);
	for (int i = 1; i < num_client; i++)
	{
		waters_pCombine(g1, g1, clients_g1[i]);
		element_printf("the server combines the contribution to public paramter by the %d-th user\n",i);
	}


	// the trusted repository server computation END

	// benchmark kCombine
	dk *decryption_keys = malloc(sizeof(dk) * (num_client));
	for (int i = 0; i < num_client; i++)
	{
		element_init_G1(decryption_keys[i][0], pp->pairing);
		element_init_G1(decryption_keys[i][1], pp->pairing);
		element_set(decryption_keys[i][0], clients_dks[0][i][0]);
		element_set(decryption_keys[i][1], clients_dks[0][i][1]);

		for (int j = 1; j < num_client; j++)
		{
			waters_kCombine(decryption_keys[i], decryption_keys[i], clients_dks[j][i]);
			element_printf("combining the decryption key for %d-th user from %d-th user\n",i,j);
		}
	}

	element_t M;
	element_init_GT(M, pp->pairing);
	unsigned char *str = calloc(1, element_length_in_bytes(M));
	strcpy((char *)str, "hello");

	element_from_bytes(M, str);

	ct CT;
	for (int test_id = 1; test_id <= num_client; test_id++)
	{
		element_printf("encrypt the message for the user with id = %d\n",test_id);
		waters_enc(CT, pp, g1, test_id, M);
		element_t DM;
		waters_dec(DM, pp, CT, decryption_keys[test_id - 1]);
		element_printf("decrypt the cipheretext\n");
		element_to_bytes(str, DM);
		element_printf(" decrypted message is %s\n", str);
	}


	for (int i = 0; i < num_client; i++)
	{

		element_clear(clients_sk[i]);
		element_clear(clients_g1[i]);
		element_clear(Tptr[i]);
		element_clear(cptr[i]);
		element_clear(wptr[i]);
		element_clear(decryption_keys[i][0]);
		element_clear(decryption_keys[i][1]);

	}
	free(clients_sk);
	free(clients_g1);

	free(Tptr);
	free(cptr);
	free(wptr);

	free(decryption_keys);

	for (int i = 0; i < num_client; i++)
	{
		for (int j = 0; j < num_client; j++)
		{
			element_clear(clients_dks[i][j][0]);
			element_clear(clients_dks[i][j][1]);
		}
		free(clients_dks[i]);
	}
	free(clients_dks);
	element_clear(g1);

}
